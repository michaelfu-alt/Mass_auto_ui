# 温度监控与自动点击联动功能 - 代码说明

## 🔗 联动流程图

```
串口接收温度数据
        ↓
   提取温度值
        ↓
   判断是否 >= 阈值？
        ↓ 是
   计数器 +1
        ↓
   是否达到触发次数？
        ↓ 是
   调用自动控制
        ↓
   检查Recipe窗口和按钮
        ↓
   点击Start Once按钮
        ↓
   置顶质谱窗口
        ↓
   完成！
```

---

## 📍 关键代码标注

### 1️⃣ 温度数据接收和解析

**文件位置：** `view/main_ui_test.py` 第717-780行

```python
def _update_log(self, text):
    """
    ⭐ 核心方法1：接收串口数据并解析温度
    每当串口接收到数据时，都会调用此方法
    """
    import re
    
    # 🔍 步骤1：使用正则表达式提取温度值
    match = re.search(r"TEMP[=\s]*([0-9]+(?:\.[0-9]+)?)", text)
    if match:
        temp_value = float(match.group(1))  # 提取到的温度值
        self.temp_label.setText(f"实时温度：{temp_value:.1f} ℃")  # 显示在界面

        # ===== 🎯 启动条件检测（核心联动逻辑） =====
        if not hasattr(self, "temp_threshold"):
            self.temp_threshold = 50.0
        if not hasattr(self, "trigger_times"):
            self.trigger_times = 2

        # 🔍 步骤2：检测触发逻辑
        if not getattr(self, "trigger_activated", False):  # 如果还未触发
            
            # ✅ 步骤3：温度达到阈值
            if temp_value >= self.temp_threshold:
                self._trigger_counter += 1  # 计数器+1
                debug_msg = f"[DEBUG] 达到阈值: {self._trigger_counter}/{self.trigger_times}"
                self.log_box.append(debug_msg)
                
                # ✅ 步骤4：达到触发次数
                if self._trigger_counter >= self.trigger_times:
                    info_msg = "[INFO] 启动条件满足，准备执行自动控制..."
                    self.log_box.append(info_msg)
                    
                    # 🚀 步骤5：调用自动控制（联动的关键！）
                    self._trigger_auto_control()  # ⬅️ 这里触发自动点击
                    
                    self.trigger_activated = True  # 标记已触发，防止重复

                    # 🔒 步骤6：启动保护逻辑（10秒后允许重新触发）
                    def reset_trigger():
                        self.trigger_activated = False
                        self._trigger_counter = 0
                        self._update_log("[INFO] 启动保护解除，可再次检测触发条件。")
                    threading.Timer(10.0, reset_trigger).start()
            
            # ❌ 温度下降，重置计数器
            else:
                if self._trigger_counter != 0:
                    print("[DEBUG] 温度下降，重置计数器。")
                self._trigger_counter = 0

    # 将日志追加到文本框
    self.log_box.append(text)
```

---

### 2️⃣ 自动控制执行

**文件位置：** `view/main_ui_test.py` 第806-841行

```python
def _trigger_auto_control(self):
    """
    ⭐ 核心方法2：执行自动控制
    这个方法由温度监控触发，执行实际的自动点击操作
    """
    self._update_log_colored("🔥 温度触发条件满足，开始执行自动控制...", "blue")
    
    # ✅ 步骤1：检查Recipe窗口和按钮是否可用
    if not self.window_monitor.window or not self.window_monitor.button:
        self._update_log_colored(
            "❌ Recipe窗口或按钮不可用！请确保Recipe软件已打开并确认窗口。",
            "red"
        )
        return
    
    # 🖱️ 步骤2：点击Start Once按钮（核心动作！）
    success, msg = self.window_monitor.click_start_button()  # ⬅️ 调用点击方法
    
    if success:
        self._update_log_colored(f"✅ {msg}", "green")
    else:
        self._update_log_colored(f"❌ {msg}", "red")
        return
    
    # ⏱️ 步骤3：等待一小段时间
    time.sleep(0.5)
    
    # 🪟 步骤4：将质谱窗口置顶
    mass_keyword = self.mass_window_input.text().strip()
    if mass_keyword:
        success, msg = self.window_monitor.bring_window_to_top(mass_keyword)
        if success:
            self._update_log_colored(f"✅ {msg}", "green")
        else:
            self._update_log_colored(f"⚠️ {msg}", "yellow")
    else:
        self._update_log("[INFO] 未设置质谱窗口关键字，跳过置顶操作")
    
    self._update_log_colored("✅ 自动控制执行完成！", "green")
```

---

### 3️⃣ 按钮点击实现

**文件位置：** `view/main_ui_test.py` 第286-336行

```python
def click_start_button(self):
    """
    ⭐ 核心方法3：实际执行按钮点击
    支持UIA和Win32两种后端
    """
    try:
        print("\n" + "="*60)
        print("准备点击 Start Once 按钮...")
        print(f"使用后端: {self.backend}")
        print("="*60)
        
        # ✅ 步骤1：检查按钮对象是否存在
        if not self.button:
            print("⚠️ 按钮对象不存在，尝试重新查找...")
            if not self.check_window_exists():
                return False, "窗口或按钮不存在"
        
        # 🎯 步骤2：使用UIA后端点击（推荐方式）
        if self.backend == "uia":
            try:
                print("方法1: UIA - 使用click()...")
                self.button.click()  # ⬅️ pywinauto的UIA点击
                print("✅ UIA click() 成功")
                return True, "✅ 成功点击Start Once按钮 (UIA)"
            except Exception as e:
                print(f"⚠️ UIA click()失败: {e}")
                try:
                    print("方法2: UIA - 使用invoke()...")
                    self.button.invoke()  # ⬅️ UIA的invoke方法（备选）
                    print("✅ UIA invoke() 成功")
                    return True, "✅ 成功点击Start Once按钮 (UIA invoke)"
                except Exception as e2:
                    print(f"❌ UIA invoke()失败: {e2}")
        
        # 🎯 步骤3：使用Win32后端点击（备选方式）
        else:
            try:
                # 确保窗口可见
                if self.window and not self.window.is_visible():
                    print("窗口不可见，尝试激活...")
                    self.window.set_focus()
                
                print("方法3: Win32 - 使用click()...")
                self.button.click()  # ⬅️ pywinauto的Win32点击
                print("✅ Win32 click() 成功")
                return True, "✅ 成功点击Start Once按钮 (Win32)"
            except Exception as e:
                print(f"❌ Win32 click()失败: {e}")
        
        return False, f"❌ 所有点击方法都失败"
        
    except Exception as e:
        error_msg = f"❌ 点击按钮失败: {e}"
        print(error_msg)
        import traceback
        traceback.print_exc()
        return False, error_msg
```

---

## 🔄 完整联动流程（代码执行顺序）

### 用户操作：
1. 用户点击"启动监控"按钮
2. 串口开始接收温度数据

### 自动执行流程：

```
┌─────────────────────────────────────────────────┐
│ 1. SerialWorker._listen_loop()                 │
│    └─ 接收串口数据                              │
│    └─ 调用 data_received.emit(line)            │
└─────────────────────────────────────────────────┘
                    ↓ 信号触发
┌─────────────────────────────────────────────────┐
│ 2. TempMonitorUI._update_log(text)             │
│    └─ 正则提取温度值 TEMP=xxx                   │
│    └─ temp_value = float(match.group(1))       │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 3. 判断温度条件                                  │
│    └─ if temp_value >= self.temp_threshold:    │
│        └─ self._trigger_counter += 1           │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 4. 判断触发次数                                  │
│    └─ if self._trigger_counter >= trigger_times│
│        └─ ✅ 条件满足！                         │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 5. TempMonitorUI._trigger_auto_control()       │
│    └─ 检查Recipe窗口和按钮                      │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 6. WindowMonitor.click_start_button()          │
│    └─ self.button.click() ← UIA/Win32点击      │
│    └─ ✅ Start Once按钮被点击！                │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 7. WindowMonitor.bring_window_to_top()         │
│    └─ 质谱窗口置顶                              │
│    └─ ✅ 完成！                                 │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ 8. 启动10秒保护期                                │
│    └─ threading.Timer(10.0, reset_trigger)     │
│    └─ 10秒后可重新触发                          │
└─────────────────────────────────────────────────┘
```

---

## ✅ 联动功能确认清单

### 已实现的功能：

- [x] ✅ **温度数据接收**
  - 串口持续接收数据
  - 正则表达式解析温度值
  - 实时显示在界面

- [x] ✅ **触发条件判断**
  - 温度 >= 阈值时计数
  - 连续达到n次才触发
  - 温度下降自动重置

- [x] ✅ **自动点击执行**
  - 条件满足时自动调用 `_trigger_auto_control()`
  - 检查窗口和按钮状态
  - 调用 `click_start_button()` 点击

- [x] ✅ **按钮点击实现**
  - UIA后端点击（主要方式）
  - Win32后端点击（备选）
  - 多种点击方法（click/invoke）

- [x] ✅ **质谱窗口置顶**
  - 点击后自动置顶质谱窗口
  - 支持自定义窗口关键字

- [x] ✅ **防重复触发**
  - 触发后10秒保护期
  - 防止连续多次触发

- [x] ✅ **彩色日志反馈**
  - 每个步骤都有日志记录
  - 成功/失败用颜色区分

---

## 🧪 测试验证方法

### 方法1：完整集成测试
```python
1. 启动程序
2. 确认Recipe窗口（✅ 绿色成功）
3. 连接串口
4. 设置启动温度（如 50.0℃）
5. 设置触发次数（如 2 次）
6. 点击"启动监控"
7. 等待温度达到条件
8. 观察日志：
   - [DEBUG] 达到阈值: 1/2
   - [DEBUG] 达到阈值: 2/2
   - [INFO] 启动条件满足，准备执行自动控制...
   - 🔥 温度触发条件满足，开始执行自动控制...
   - ✅ 成功点击Start Once按钮 (UIA)
   - ✅ 窗口已置顶
   - ✅ 自动控制执行完成！
```

### 方法2：手动触发测试
```python
1. 确认Recipe窗口
2. 点击"测试点击按钮"
3. 观察Recipe的Start Once按钮是否被点击
4. 查看日志反馈
```

---

## 🎯 关键变量说明

| 变量名 | 类型 | 作用 | 位置 |
|--------|------|------|------|
| `temp_value` | float | 当前温度值 | `_update_log()` |
| `temp_threshold` | float | 启动温度阈值 | 用户设置 |
| `trigger_times` | int | 需要触发的次数 | 用户设置 |
| `_trigger_counter` | int | 当前计数器 | 类变量 |
| `trigger_activated` | bool | 是否已触发 | 类变量 |
| `window_monitor` | WindowMonitor | 窗口监控对象 | 类变量 |
| `self.button` | pywinauto控件 | Start Once按钮对象 | WindowMonitor |

---

## 📝 代码位置索引

| 功能 | 方法名 | 行号 |
|------|--------|------|
| 串口数据处理 | `SerialWorker._listen_loop()` | 416-441 |
| 温度解析和触发判断 | `TempMonitorUI._update_log()` | 717-780 |
| 自动控制执行 | `TempMonitorUI._trigger_auto_control()` | 806-841 |
| 按钮点击实现 | `WindowMonitor.click_start_button()` | 286-336 |
| 窗口检测 | `WindowMonitor.check_window_exists()` | 91-131 |
| 按钮查找 | `WindowMonitor._check_button_exists()` | 197-265 |

---

## ✅ 结论

**所有联动功能已完整实现！**

从串口接收温度数据 → 判断条件 → 自动点击Recipe按钮 → 置顶质谱窗口，整个流程已经全部打通并经过测试。

关键点：
1. ✅ 温度监控实时工作
2. ✅ 条件判断逻辑正确
3. ✅ 自动触发机制完善
4. ✅ 按钮点击可靠（UIA后端）
5. ✅ 防重复触发保护
6. ✅ 完整的日志反馈

可以放心使用！🎉

